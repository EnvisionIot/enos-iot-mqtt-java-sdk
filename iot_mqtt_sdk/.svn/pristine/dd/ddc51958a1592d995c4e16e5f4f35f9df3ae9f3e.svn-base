package com.envisioniot.enos.iot_mqtt_sdk.core.internals;

import java.util.List;
import java.util.Map;
import java.util.TimerTask;
import java.util.concurrent.*;

import com.envisioniot.enos.iot_mqtt_sdk.core.profile.Profile;
import com.google.common.util.concurrent.ThreadFactoryBuilder;
import org.eclipse.paho.client.mqttv3.IMqttDeliveryToken;
import org.eclipse.paho.client.mqttv3.MqttCallback;
import org.eclipse.paho.client.mqttv3.MqttClient;
import org.eclipse.paho.client.mqttv3.MqttException;
import org.eclipse.paho.client.mqttv3.MqttMessage;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.envisioniot.enos.iot_mqtt_sdk.core.IResponseCallback;
import com.envisioniot.enos.iot_mqtt_sdk.core.exception.EnvisionError;
import com.envisioniot.enos.iot_mqtt_sdk.core.exception.EnvisionException;
import com.envisioniot.enos.iot_mqtt_sdk.core.msg.IMessageHandler;
import com.envisioniot.enos.iot_mqtt_sdk.core.msg.IMqttArrivedMessage;
import com.envisioniot.enos.iot_mqtt_sdk.core.msg.IMqttDeliveryMessage;
import com.envisioniot.enos.iot_mqtt_sdk.core.msg.IMqttRequest;
import com.envisioniot.enos.iot_mqtt_sdk.core.msg.IMqttResponse;
import com.envisioniot.enos.iot_mqtt_sdk.core.msg.IMqttArrivedMessage.DecodeResult;

/**
 *
 * @author zhensheng.cai
 * @date 2018/7/5.
 */
public class DefaultProcessor implements MqttCallback
{
	private static Logger logger = LoggerFactory.getLogger(DefaultProcessor.class);
	private MqttClient mqttClient;
	/**
	 * response execution pool
	 */
	private ExecutorService executor;
	/**
	 * callback timeout pool
	 * */
	private ScheduledExecutorService timeoutScheduler = new ScheduledThreadPoolExecutor(1,
			new ThreadFactoryBuilder().setNameFormat("callback-timeout-pool-%d").build());

	public DefaultProcessor(MqttClient mqttClient , Profile profile)
	{
		this.mqttClient = mqttClient;
		this.executor = profile.getExecutorService();
	}

	private final Map<String, Task<? extends IMqttResponse>> rspTaskMap = new ConcurrentHashMap<>();
	private final Map<Class<? extends IMqttArrivedMessage>, IMessageHandler<?, ?>> arrivedMsgHandlerMap = new ConcurrentHashMap<>();
	

	@Override
	public void messageArrived(String topic, MqttMessage mqttMessage) throws Exception
	{
		try
		{
			if (logger.isDebugEnabled())
			{
				logger.debug("{} , {}", topic, mqttMessage);
			}

			DecodeResult result = null;
			List<IMqttArrivedMessage> decoderList = DecoderRegistry.getDeocderList();
			for (IMqttArrivedMessage decoder : decoderList)
            {
			    result = decoder.decode(topic, mqttMessage.getPayload());
			    if(result != null)
			    {
			        break;
			    }
            }
			
			// 1. decoder
			if (result == null)
			{
				logger.error("decode the rcv message failed , from topic {}", topic);
				return;
			}
			
			IMqttArrivedMessage msg = result.getArrivedMsg();
			if (msg == null)
			{
				logger.error("decode msg failed , from topic{} ", topic);
				return;
			}
			
			
			
			// 2. handle the msg
			if (msg instanceof IMqttResponse)
			{
			    IMqttResponse mqttRsp = (IMqttResponse) msg;
			    
			    @SuppressWarnings("unchecked")
                Task<IMqttResponse> task = (Task<IMqttResponse>) rspTaskMap.remove(topic + "_" + mqttRsp.getMessageId());
			    if(task == null)
			    {
			        logger.error("no request answer the response , topic {}  ,msg {} ", topic, msg);
			        return;
			    }
			    
			    task.run(mqttRsp);
			}
			
			@SuppressWarnings("unchecked")
            final IMessageHandler<IMqttArrivedMessage, IMqttDeliveryMessage> handler = (IMessageHandler<IMqttArrivedMessage, IMqttDeliveryMessage>) arrivedMsgHandlerMap.get(msg.getClass());
			final List<String> pathList = result.getPathList();
			if(handler != null)
			{
			    // TODO: 是否还需要ICommandAdvice的处理
			    executor.execute(new Runnable()
                {
                    
                    @Override
                    public void run()
                    {
                        try
                        {
                            handler.onMessage(msg, pathList);
                        }
                        catch (Exception e)
                        {
                            e.printStackTrace();
                        }
                    }
                });
			}
			else
			{
			    //TODO: 这里没有注册，如果是command需要告诉给服务端没有订阅，无法响应
			}
		}
		catch (Exception e)
		{
			logger.error("UGLY INTERNAL ERR!! , processing the arrived  msg err , topic {}  uncaught exception : ",
					topic, e);
		}
	}


	
	public <T extends IMqttResponse> void createCallbackTask(IMqttRequest<T> request, final IResponseCallback<T> callback , long timeout) throws EnvisionException
	{
		/*do expire*/
		if(callback != null)
	    {
			final Task<T> task = new Task<T>();
			String key = request.getAnswerTopic() + "_" + request.getMessageId();
			Boolean isTimeout = true;

			FutureTask<Boolean> futureTask = new FutureTask<Boolean>(new Runnable()
			{
				@Override public void run()
				{
					logger.warn("callback task timeout {} ", key);
					rspTaskMap.remove(key);
				}
			}, isTimeout);
			task.setRunable(new Runnable()
			{
				@Override public void run()
				{
					callback.onResponse(task.rsp);
					logger.info("cancel the future timeout task  {} " , key);
					futureTask.cancel(true);
				}
			});
			timeoutScheduler.schedule(futureTask, timeout , TimeUnit.MILLISECONDS);
			rspTaskMap.put(key, task);
	    }
	    
	    try
        {
            request.check();
            mqttClient.publish(request.getMessageTopic(), request.encode(), request.getQos(), false);
        }
        catch (MqttException e)
        {
            logger.error("publish message failed messageRequestId {} ", request.getMessageTopic());
            throw new EnvisionException(e.getMessage(), e.getCause(), EnvisionError.MQTT_CLIENT_PUBLISH_FAILED);
        }
	}
	
	public <T extends IMqttResponse> FutureTask<T> createFutureTask(IMqttRequest<T> request) throws EnvisionException
	{
	    String key = request.getAnswerTopic() + "_" + request.getMessageId();
	    Task<T> task = new Task<T>();
	    
	    FutureTask<T> future = new FutureTask<>(task);
	    task.setRunable(future);
	    rspTaskMap.put(key, task);
	    
        try
        {
            request.check();
            mqttClient.publish(request.getMessageTopic(), request.encode(), request.getQos(), false);
        }
        catch (MqttException e)
        {
            logger.error("publish message failed messageRequestId {} ", request.getMessageTopic());
            throw new EnvisionException(e.getMessage(), e.getCause(), EnvisionError.MQTT_CLIENT_PUBLISH_FAILED);
        }
        
	    return future;
	}
	
	public void setArrivedMsgHandler(Class<? extends IMqttArrivedMessage> arrivedMsgCls, IMessageHandler<?, ?> handler)
	{
	    arrivedMsgHandlerMap.put(arrivedMsgCls, handler);
	}
	
	public void removeArrivedMsgHandler(String topic)
	{
	    arrivedMsgHandlerMap.remove(topic);
	}

	@Override
	public void connectionLost(Throwable throwable)
	{
	    /*
		if (logger.isDebugEnabled())
		{
			logger.debug("", throwable);
		}
		logger.error("Client <{}> Connection Lost ", this.connectClient.getClientId());

		if (connectClient.isCleanSession())
		{
			logger.info("clear the subscriptions");
			this.connectClient.clearSubscription();
		}
		*/
	}

	@Override
	public void deliveryComplete(IMqttDeliveryToken iMqttDeliveryToken)
	{
		if (logger.isDebugEnabled())
		{
			logger.debug("delivery complete");
		}
	}

	//private static class Task

	private static class Task<T extends IMqttResponse> implements Callable<T>
	{
	    private volatile T rsp;
	    private Runnable runable;
	    
	    public void setRunable(Runnable runable)
        {
            this.runable = runable;
        }
	    
	    public void run(T rsp)
	    {
	        this.rsp = rsp;
	        runable.run();
	    }

        @Override
        public T call() throws Exception
        {
            return rsp;
        }
	}
	
	public static void main(String[] args) throws InterruptedException, ExecutionException, TimeoutException
    {
	    final FutureTask<String> future = new FutureTask<>(new Callable<String>()
        {

            @Override
            public String call() throws Exception
            {
                return "abc";
            }
        });
	    
	    new Thread()
	    {
	        public void run()
	        {
	            try
                {
                    Thread.sleep(1000 * 5);
                }
                catch (InterruptedException e)
                {
                    // TODO Auto-generated catch block
                    e.printStackTrace();
                }
	            future.run();
	        }
	    }.start();


		new Thread()
		{
			public void run()
			{
				try
				{
					Thread.sleep(1000 * 2);
				}
				catch (InterruptedException e)
				{
					// TODO Auto-generated catch block
					e.printStackTrace();
				}
				System.out.println("canneled ");
				future.cancel(true);
			}
		}.start();


		System.out.println("hello");
	    System.out.println(future.get(10, TimeUnit.SECONDS));
    }
}
